\section{Blocks}
A file consist of blocks, which are either:
\begin{itemize}
\item variable blocks, describing the variables expected from the UDP client;
\item window definitions, describing the windows and the frames and widgets
they contain;
\item configuration options.
\end{itemize}

\begin{v}
file        ::= { block }

block       ::= varblock
            |   window
            |   configoption
\end{v}

\subsection{Configuration options}
These are defined at the top level:
\begin{itemize}
\item \textbf{validtime} : if a data buffer has not received data for this long, the data in the buffer is 
considered to be invalid. This is useful when there is a reasonably good connection and a long wait between updates
is a symptom of a fault. It is set by default to a very long interval (about two years.)
\item \textbf{port} : this is the port to which the system should listen for UDP packets --- by default 13231, although
it can be set with the \verb+-p+ option on the command line, which will override any value set in the configuration file.
\item \textbf{sendaddr} : this string is a hostname to which UDP control packets can be sent by output widgets, such as 
switches. By default it is the local host.
\item \textbf{sendport} : this is the port number for UDP control packets, by default 33333.
\item \textbf{sendinterval} : the interval between sends of UDP packets for \emph{always send} widgets, by default 2 seconds.
\item \textbf{updateinterval} : the time between ticks at which all graphics are updated, by default 2 seconds.
\end{itemize}
\begin{v}
configoption::= 'port' int
            |   'sendaddr' string
            |   'sendport' int
            |   'validtime' float
            |   'sendinterval' float
            |   'updateinterval' float
\end{v}

\subsection{Variable blocks}
Variable blocks describe the variables which arrive on the UDP
connection, and consist of a list of variable definitions surrounded
by curly brackets\footnote{change from first version, for syntactical orthogonality.}.
\begin{v}
varblock    ::= 'var' '{' {vardef} '}'
\end{v}
Currently only floating point variables are supported.
Some floating point variables may be \emph{linked.}

A normal floating point variable definition specifies the name of the variable
(an identifier,) the size of the cyclic buffer backing the variable,
and a range specification.

A linked variable definition consists of a number of variables,
separated by commas, in brackets; followed by a buffer size.
Linked variable specifications give the name of the variable and
a range (which cannot be `auto' --- see below.)
\begin{v}
vardef      ::= 'float' varname buffersize 'range' rangespec
            |   'linked' '(' { linkedvar ',' } linkedvar ')' buffersize

linkedvar   ::= 'float' varname 'range' <float> to <float>

buffersize  ::= int
varname     ::= ident
            
\end{v}
When a message arrives giving the value of a linked variable, dummy
entries with the same timestamp are created for other variables
in the link with the previous value those variables had. Linked
variables are used for sets of variables which comprise a single
entity, such as latitude and longitude or \emph{xyz} coordinates,
where if a change is received on one variable the others should be
considered to have changed even though an explicit change was not
sent.

Range specifications describe the values a variable can take in
normal operation --- these are the values any widget viewing this
variable will be able to show. If the range is specified as \emph{auto},
the range will be determined dynamically. Linked variables cannot
have auto range.
\begin{v}
<rangespec> ::= <float> to <float>
                | auto
\end{v}

\subsection{Window blocks}
Window blocks describe the contents of a window. Windows can appear
on any display, and can be fullscreen if desired.
There are a number of options:
\begin{itemize}
\item the title of the window can be set;
\item the window can be set to fullscreen;
\item the size of the window can be set --- default is as small as possible, and this option
is ignored in fullscreen windows;
\item a `screen' can be set, in which case the system will be scanned for a display of the given
size and the window placed on that window.
\item a window can be specified as ``inverse'' --- black on white. This may
be easier to read in bright light, but looks ugly.
\end{itemize}

\begin{v}
window      ::= 'window' [ {windowopt} ] '{' {frame|widget} '}'
windowopt   ::= 'title' string
            |   'fullscreen'
            |   'size' int ',' int
            |   'screen' int ',' int
            |   'inverse'
\end{v}


\subsection{Frame blocks}
Frame blocks describe a frame within the window, optionally surrounded by a border, and its contents.
The frame definition consists of a position (see below) giving the position and size of the frame within its container,
some options, and then a list of contents in curly brackets --- which can be widgets or more frames, just like for a window.
\begin{v}
frameblock  ::= 'frame' pos [{frameopt}] '{' {frame|widget} '}'

frameopt    ::= 'borderless'
            |   'spacing' int

\end{v}

\subsubsection{Positions}
Positions describe where elements appear in a container's
grid layout, and how many rows and columns they take up. They
are either an x,y pair (with an implied width and height) or a full
x, y, w, h set.

In addition, a position for a widget
can optionally be followed by a size, giving the \emph{minimum} pixel size of
the widget in both x and y. If only one number is given, the same value is
used for both dimensions.
\begin{v}
pos         ::=  x ',' y [ ',' w ',' h ] [ 'size' minw [ ',' minh ] ]

x           ::= int
y           ::= int
w           ::= int
h           ::= int
minw        ::= int
minh        ::= int
\end{v}
Minimum size options on frames and windows are ignored.

\subsection{Widgets}
All widget specification consist of the widget type, followed by the position,
followed by widget specification in curly brackets.

\begin{v}
widget      ::= gauge | number | graph | map | status |
                compass | switch | momentary | slider
\end{v}

\subsubsection{Sources}
A source specification describes a data source. It is either a
variable, or an expression and a range.
\begin{v}
source      ::= 'var' varname
            |   'expr' string 'range' rangespec
\end{v}
An expression is an infix expression in double quotes consisting of:
\begin{itemize}
\item names of variables declared in the \textbf{var} blocks;
\item float constants;
\item the four arithmetic operators with their usual precedence;
\item the comparison operators \verb+<+ \verb+>+ \verb+>=+ \verb+<=+ 
\verb+!=+ \verb+=+
\item the logical negate operator ``!''
\item the logical operators \verb+&&+ and \verb+||+.
\end{itemize}

\subsubsection{Gauge widgets}
A gauge widget consists of the position, followed by any of the following,
some of which are mandatory:
\begin{itemize}
\item a \textbf{source specification} (mandatory)
\item a \textbf{position specification} (mandatory)
\item a \textbf{title string} giving the gauge's label --- without this,
the variable name or expression string from the source are used;
\item a \textbf{subtitle string} giving a smaller label, which is empty
by default;
\item a \textbf{levels specification} giving the value of the warning
and danger levels in terms of the input source range --- if the source range is
auto, these should be 0-1. If \emph{previous} is specified, the preceding
level specification is used;
\item a \textbf{colours} specification giving colours for 
the normal, warn and danger ticks;
\item a \textbf{darken} factor, giving the value used to darken the colours
to show the ``off'' ticks on the gauge. The default is 400, which means that
the dark colour is a quarter of the bright colour. The higher the value, 
the darker the colour. A \emph{previous} value is also accepted.
\end{itemize}
\begin{v}
gauge       ::= 'gauge' pos '{' { gaugemod } '}'
gaugemod    ::=
            |   source
            |   'title' string
            |   'subtitle' string
            |   'levels' levelspec
            |   'colours' grcolspec
            |   'fontscale' float
            |   'darken' (int | 'previous')

levelspec   ::= warnlevel dangerlevel
            |   'previous'
            
grcolspec   ::= normcol warncol dangercol
            |   'previous'
            
normcol     ::= colour
warncol     ::= colour
dangercol   ::= colour

colour      ::= colourname
            |   '"#' hexdigit hexdigit hexdigit '"'

warnlevel   ::= float            
dangerlevel ::= float            
\end{v}

\subsubsection{Number widgets}
Number widgets consists of a position, an optional title and
a source.
\begin{v}
number      ::= 'number' pos '{' [ 'title' string ] source '}'
\end{v}

\subsubsection{Graph widgets}
This consists of a position, a time value (giving
the width of the graph in seconds) and a list of graph
sources.

Each source consists of a source specification and a set
of graph modifiers in curly brackets, which describe the
style of line drawn for that source.

\begin{v}
graph       ::= 'graph' pos '{' [ 'time' float ] { graphsource } '}'

graphsource ::= source '{' { graphmod } '}'

graphmod    ::= 'width' float 
            |   'colour' colour
\end{v}

\subsubsection{Maps}
A map shows an map image with points overlaid. It consists
of a screen position, as with other widgets,
followed by a set of map points or vectors to render.

\begin{v}
map         ::= 'map' pos '{' { mappoint|mapvector } '}'
\end{v}

\textbf{Map points} represent data as circles on the map
whose colour and screen size depends on data sources.
Their definitions consist of the word `point' followed
by a point specification in curly brackets.
This consists of a location specification
(two sources separated by commas for latitude and longitude
respectively) followed by a list of map point modifiers.
These describe how the point is drawn. Finally, there should
be an `on' clause, which specifies how new points are drawn ---
a new point is created whenever a new datum value
arrives in this source.

The point modifiers can be a a base colour (white by default),
a hue clause specifying a source which can be mapped onto the 
hue range, similar saturation and value sources, a default
size, and a size range clause mapping a source onto a size range
which replaces the default size. A trail size can also be specified
to allow a number of historical points to be rendered.

\begin{v}
mappoint    ::= 'point' '{' location [{ pointmod }] 'on' source '}'

pointmod    ::= 'colour' colour
            |   'hue' source
            |   'saturation' source
            |   'value' source
            |   'size' float
            |   'trail' int
            |   'sizerange' minsize maxsize source

location    ::= lat ',' long
lat         ::= source
long        ::= source
\end{v}

\textbf{Map vectors} are similar to points, but represent data
by a line coming from a point on the map. The line's starting location,
length (in pixels), colour and width can be modified by data sources
in a similar way to the size and colour of a point.

\begin{v}
mapvector    ::= 'vector' '{' location [{ vectormod }] 'on' source '}'

vectormod    ::= 'colour' colour
            |   'hue' source
            |   'saturation' source
            |   'value' source
            |   'width' float
            |   'widthrange' minsize maxsize source
            |   'length' float
            |   'lengthrange' minsize maxsize source
            |   'trail' int

location    ::= lat ',' long
lat         ::= source
long        ::= source
\end{v}

\subsubsection{Status widgets}
A status widget consists of a position, a grid size specification
(giving the number of rows and columns of indicators in the grid)
and then a set of status indicators, which currently are all
of type \emph{floatrange.} 

\begin{v}
status      ::= 'status' pos '{' 
                'size' int ',' int
                { floatrange }
               '}'
\end{v}

Each floatrange indicator consists of `floatrange', and a specification
in curly brackets containing a grid position, a title, a source
and then a set of bands. Optionally there can then follow a set
of \emph{when} clauses, which specify alternate title strings
to use when the indicator is a particular colour.
\begin{v}
floatrange  ::= 'floatrange' '{' 
                    'pos' int ',' int
                    'title' string
                    source
                    bands
                    [{ 'when' statcolour string }]
                '}'
\end{v}
The bands in a status indicator consist of `bands' followed by
a set of band specifications, each of which is a less-than sign,
a float, and a colour. When a value is received on the source,
is goes through each of these bands is first, and the first for
which the comparison is true gives the colour. The bands end
with an \emph{else} clause giving the default colour.

An alternative form of band specification is the word `previous,'
which means ``copy the bands from the previous indicator's
specification.'' It is an error to use this in the first indicator.
\begin{v}
bands       ::= 'bands' ( fullbands | 'previous' )
fullbands   ::= { '<' float statcolour }
                'else' statcolour
statcolour  ::= 'red' | 'green' | 'blue' | 'black' | 'yellow'
\end{v}
\todo{BOOL blocks are missing from the docs}
               
\subsubsection{Compass}
The compass widget simply shows a heading. Its source is a value
in degrees:
\begin{v}
compass     ::= 'compass' pos '{'
                [ 'title' string ]
                source
                '}'
\end{v}


\subsubsection{Switch}
The toggle switch is an output widget --- that is, its primary purpose is to
send data out via a UDP packet. Switches can operate with or without a
``feedback source.'' If such a source is set, the switch's visible state is
compared with the value of this source and any mismatch indicated. Without a
feedback source, the packets are sent from the switch with no indication of
whether they were successfully received. The actual data sent (and received)
by the switch are booleans in the form of floats, 0 or 1.

In non-feedback mode, the switch has two states:
\begin{itemize}
\item \textbf{red} corresponds to 0
\item \textbf{green} corresponds to 1
\end{itemize}
In feedback mode, the switch has four states:
\begin{itemize}
\item \textbf{red} corresponds to 0 sent and acknowledged;
\item \textbf{green} corresponds to 1 sent and acknowledged;
\item \textbf{grey} means the value has been changed locally, but has not yet been sent. You can set \emph{immediate} to
make sure a value is sent immediately on change;
\item \textbf{diagonal crosshatch} means a value has been sent (indicated by the colour) but a feedback value has
not yet been received;
\item \textbf{full crosshatch} means a value has been sent (indicated by the colour) and a feedback value has
been received, but the two do not match --- an error condition.
\end{itemize}
Switch specifications consist of a position, the name of an
output variable to use in the send packets, a title,
an an optional feedback source. There may also be the word \verb+always+, in which case the value for this switch
is always sent, whenever any other output widget changes and when the send interval elapses; and the word `immediate'
indicating that when the switch is pressed, a UDP send update should be done immediately. This will result in the
switch's data being sent, as well as any data for other `always' output widgets.
\begin{v}
switch      ::= 'switch' pos '{'
                    'out' ident
                    [ 'title' string ]
                    [ source ]
                    [ 'always' ]
                    [ 'immediate' ]
                    [ 'key' keyname ]
                '}'
\end{v}

\subsubsection{A note on keys}
Note that a switch can have a key mapped onto it. The key name is a string (delimited by quotes)
which is either an ASCII character, or one of the following:

\begin{center}
\begin{tabular}{llll}
home & end & pgup & pgdn \\
ins & del & up & down \\
left & right & \\
\end{tabular}
\end{center}


\subsubsection{Momentary}
A momentary button is an output widget, similar to a switch. It also has a feedback source, in a similar manner to a switch ---
the button's feedback is valid if it is above 0.5 and the packet setting it arrives after the button was pressed.

Momentary buttons use a similar colour scheme to that of a switch:
\begin{itemize}
\item \textbf{green} means the button is ready;
\item \textbf{red} means the button has recently been pressed and acknowledged,
and will soon return to the green state (this a purely cosmetic state;)
\item \textbf{grey} means the button has been pressed, but data has not yet been sent. You can set \emph{immediate} to
make sure a value is sent immediately on change;
\item \textbf{diagonal crosshatch} means the press has been sent (indicated by the colour) but a feedback value has
not yet been received;
\item \textbf{full crosshatch} means a value has been sent (indicated by the colour) and a feedback value has
been received, but the two do not match (i.e. the value read is less than 0.5.)
\end{itemize}
Another use of momentary buttons is to `nudge' widgets controlling continuous values, such as sliders. Instead of a \emph{out} clause
with an output
variable name, the word \emph{nudge} and the name of the output variable of a slider is used, along with an action: \emph{up,}
\emph{down} and so on. A feedback variable is not permitted with nudge buttons.
\begin{v}
switch      ::= 'momentary' pos '{'
                    ( 'out' ident |
                      'nudge' name ('up'|'down'|'centre'|'min'|'max') )
                    [ 'title' string ]
                    [ source ]
                    [ 'always' ]
                    [ 'immediate' ]
                    [ 'key' keyname ]
                '}'
\end{v}

\subsubsection{Slider}
Sliders are output widgets which control continuous values. They
work in a similar manner to switches, but the value controlled
is a floating point value over a specified range.

A feedback source can also be specified, which is compared against
the value which has been sent. The two values must be within
a user-configurable epsilon of each other for a match (currently 0.001).

The handle of the slider shows:
\begin{itemize}
\item \textbf{white} for OK;
\item \textbf{grey} means data not yet sent;
\item \textbf{diagonal crosshatch} means data sent but no acknowledgement;
\item \textbf{full crosshatch} means data sent, but the received value is not
yet within epsilon of the sent value. This is not necessarily an error,
it may take some time for the physical system to catch up.
\end{itemize}
See ``Momentary'' for how to create button widgets which can nudge the slider.

It should be noted that \emph{immediate} with a slider works a little
differently from other widgets: the value will only be sent with the slider
handle is released. This is to avoid flooding the network with UDP packets as
the slider moves. However, using a autorepeat keys on a key-mapped momentary
to nudge a slider which is set to immediate will result in many UDP packets
being sent!

\begin{v}
slider      ::= 'slider' pos '{'
                    'out' ident
                    'range' float 'to' float
                    'initial' float
                    [ 'title' string ]
                    [ source ]
                    [ 'always' ]
                    [ 'immediate' ]
                    [ 'horizontal' | 'vertical' ]
                '}'
\end{v}




\section{Other notes}

\subsection{How output data is sent}
Whenever the output update runs, output data is sent for those widgets which are either have changed since the
last send, or are set to \emph{always send}. The output update is run every \emph{sendinterval} seconds, which defaults
to 2 seconds but can be set by the configuration file. In addition, widgets set as \emph{immediate} cause the output
update to run whenever they are changed.

\subsection{Special variables}
Some variables are created at startup:
\begin{itemize}
\item \textbf{timesincepacket} is the number of seconds since the last packet
was received. It is updated every two seconds or so.
\item \textbf{lastpacketinterval} is the number of seconds between the last
packet and the packet before that. It is updated on every packet.
\end{itemize}

